/*
 * Copyright 2011-2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.lettuce.apigenerator;

import com.github.javaparser.JavaParser;
import com.github.javaparser.JavaToken;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.NodeList;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.type.Type;
import com.github.javaparser.ast.type.TypeParameter;
import com.github.javaparser.ast.visitor.VoidVisitorAdapter;
import com.github.javaparser.javadoc.Javadoc;
import io.lettuce.core.internal.LettuceSets;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.function.Function;
import java.util.function.Supplier;

import static java.util.stream.Collectors.joining;

/**
 * @author Mikhael Sokolov
 * @author dengliming
 * @author Mark Paluch
 */
@SuppressWarnings("OptionalGetWithoutIsPresent")
class KotlinCompilationUnitFactory {

    private static final Set<String> SKIP_IMPORTS = Collections.unmodifiableSet(LettuceSets.newHashSet("java.util.List", "java.util.Set", "java.util.Map"));
    private static final String FORMATTING_INDENT = "    ";

    private final File templateFile;
    private final File target;
    private final String targetPackage;
    private final String targetName;

    private final String ops;
    private final String coroutinesInterface;
    private final Supplier<List<String>> importSupplier;
    private final Function<String, String> commentInjector;
    private final Function<MethodDeclaration, String> implBody;

    private final StringBuilder result = new StringBuilder();

    public KotlinCompilationUnitFactory(File templateFile,
                                        File sources,
                                        String targetPackage,
                                        String targetName,
                                        String opsClass,
                                        String coroutinesInterface,
                                        Supplier<List<String>> importSupplier,
                                        Function<String, String> commentInjector,
                                        Function<MethodDeclaration, String> implBody) {
        this.templateFile = templateFile;
        this.targetPackage = targetPackage;
        this.targetName = targetName;
        this.ops = opsClass;
        this.coroutinesInterface = coroutinesInterface;
        this.importSupplier = importSupplier;
        this.commentInjector = commentInjector;
        this.implBody = implBody;

        this.target = new File(sources, targetPackage.replace('.', '/') + "/" + targetName + ".kt");
    }

    public void create() throws Exception {
        CompilationUnit template = JavaParser.parse(templateFile);

        JavaToken license = template.getTokenRange().get().getBegin();
        result.append(license.asString());
        result.append(license.getNextToken().get().asString());
        result.append("\n");

        result.append("@file:Suppress(\"unused\")").append("\n\n");

        result.append("package ").append(targetPackage).append("\n\n");

        importSupplier.get().forEach(l -> result.append("import ").append(l).append("\n"));

        template
                .getImports()
                .stream()
                .filter(i -> SKIP_IMPORTS
                        .stream()
                        .noneMatch(si -> si.equals(i.getNameAsString()))
                )
                .forEach(i -> result
                        .append("import ")
                        .append(i.getNameAsString())
                        .append(i.isAsterisk() ? ".*" : "")
                        .append("\n")
                );

        result.append("\n\n");

        ClassOrInterfaceDeclaration clazz = (ClassOrInterfaceDeclaration) template.getTypes().get(0);

        result.append(commentInjector.apply(extractJavadoc(clazz.getJavadoc().get())
                .replaceAll("@author Mark Paluch", "@author \\${author}")
                .replaceAll("@since [0-9].0", "@since \\${since}")
                .replaceAll("\\*\\*/", "* @generated by \\${generator}\r\n */")
        ));

        result.append("@ExperimentalLettuceCoroutinesApi").append("\n");

        NodeList<TypeParameter> typeParameters = clazz.getTypeParameters();
        String tp = extractTypeParams(typeParameters);

        if (isInterface()) {
            result
                    .append("interface ")
                    .append(targetName)
                    .append(tp)
                    .append(" ");
        } else {
            result
                    .append("internal class ")
                    .append(targetName)
                    .append(tp)
                    .append("(")
                    .append("private val ops: ")
                    .append(ops)
                    .append(tp)
                    .append(")")
                    .append(" : ")
                    .append(coroutinesInterface)
                    .append(tp)
                    .append(" ");
        }


        result.append("{\n\n");
        new MethodVisitor().visit(template, null);
        result.append("}\n\n");

        writeResult();
    }

    private class MethodVisitor extends VoidVisitorAdapter<Object> {

        @Override
        public void visit(MethodDeclaration method, Object arg) {
            result
                    .append(FORMATTING_INDENT)
                    .append(extractJavadoc(method.getJavadoc().get()).replace("\n", "\n" + FORMATTING_INDENT))
                    .append(extractAnnotations(method))
                    .append(isInterface() ? "" : "override ")
                    .append("suspend fun ")
                    .append(method.getTypeParameters().isNonEmpty() ? extractTypeParams(method.getTypeParameters()).concat(" ") : "")
                    .append(method.getName())
                    .append("(")
                    .append(extractParameters(method))
                    .append(")")
                    .append(": ")
                    .append(toKotlinType(method.getType(), true))
                    .append(constructBody(method))
                    .append("\n\n");
        }

        private String extractAnnotations(MethodDeclaration method) {
            return method
                    .getAnnotations()
                    .stream()
                    .map(a -> {
                        String name = a.getNameAsString();
                        if ("Deprecated".equals(name)) {
                            return "@Deprecated(message = \"Use another API instead.\")" + "\n" + FORMATTING_INDENT;
                        } else {
                            return name + "\n" + FORMATTING_INDENT;
                        }
                    })
                    .collect(joining());
        }

        private String extractParameters(MethodDeclaration method) {
            return method
                    .getParameters()
                    .stream()
                    .map(p -> (p.isVarArgs() ? "vararg " : "") + p.getName() + ": " + toKotlinType(p.getType(), false))
                    .collect(joining(", "));
        }

        private String toKotlinType(Type type, boolean nullable) {
            if (type.isArrayType()) {
                Type componentType = type.asArrayType().getComponentType();
                if (componentType.asString().equals("byte")) {
                    return "ByteArray";
                } else {
                    return String.format("Array<%s>", componentType.asString());
                }
            } else if (type.isPrimitiveType()) {
                return type
                        .asPrimitiveType()
                        .toBoxedType()
                        .getName()
                        .asString()
                        .replace("Integer", "Int")
                        .replace("Object", "Any");
            } else {
                return type
                        .asString()
                        .replace("void", "Unit")
                        .replace("Object", "Any")
                        .replace("? extends", "out")
                        .replace("? super", "in")
                        .replace(",", ", ")
                        .concat(nullable ? "?" : "");
            }
        }

        private String constructBody(MethodDeclaration method) {
            if (isInterface()) {
                return "";
            }
            StringBuilder body = new StringBuilder().append(" = ");

            String params = method
                    .getParameters()
                    .stream()
                    .map(p -> (p.isVarArgs() ? "*" : "") + p.getNameAsString())
                    .collect(joining(", "));

            String await = implBody.apply(method);

            return body
                    .append("ops.")
                    .append(method.getNameAsString())
                    .append(extractTypeParams(method.getTypeParameters()))
                    .append("(")
                    .append(params)
                    .append(")")
                    .append(await)
                    .toString();
        }
    }

    public static String extractTypeParams(NodeList<TypeParameter> typeParams) {
        if (typeParams.isEmpty()) {
            return "";
        } else {
            return typeParams
                    .stream()
                    .map(tp -> tp.getName().getIdentifier())
                    .collect(joining(", ", "<", ">"));
        }
    }

    public static String extractJavadoc(Javadoc javadoc) {
        String plainJavadoc = javadoc
                .toComment().toString()
                .replace("&lt;", "<")
                .replace("&gt;", ">");

        return plainJavadoc;
    }

    private Boolean isInterface() {
        return implBody == null;
    }

    @SuppressWarnings("ResultOfMethodCallIgnored")
    private void writeResult() throws IOException {
        target.getParentFile().mkdirs();
        FileOutputStream fos = new FileOutputStream(target);
        fos.write(result.toString().getBytes());
        fos.close();
    }
}
