<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<!--
    Copyright 2010 The myBatis Team

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-->

<!--
    version: $Id$
-->
<chapter id="mappers">
  <title>MapperFactoryBean</title>

  <para>
    Rather than code data access objects (DAOs) manually, Mybatis-Spring
    provides a dynamic proxy implementation:
    <literal>MapperFactoryBean</literal>. This class lets you inject data
    mapper interfaces directly into your service beans. When using mappers you
    simply call them as you have always  called your DAOs, but you won't need
    to code any DAO implementation because MyBatis-Spring will create a proxy
    for you.
  </para>

  <para>
    With injected mappers your code will have no direct dependencies on MyBatis,
    Spring or MyBatis-Spring. The proxy that
    <literal>MapperFactoryBean</literal> creates handles opening and closing the
    session as well as translating any exceptions into Spring
    <literal>DataAccessExceptions</literal>. In addition, the proxy will
    start a new Spring transaction if required or participate in an existing
    one if necessary. 
  </para>

  <section id="mappers.setup">
    <title>Setup</title>
    <para>
      A data mapper interface is added to Spring like the following:

      <programlisting language="xml"><![CDATA[<bean id="userMapper" class="org.mybatis.spring.MapperFactoryBean">
  <property name="mapperInterface" value="org.mybatis.spring.sample.mapper.UserMapper" />
  <property name="sqlSessionFactory" ref="sqlSessionFactory" />
</bean>]]></programlisting>
    </para>

    <para>
      <literal>MapperFactoryBean</literal> creates a proxy class that
      implements <literal>UserMapper</literal> and injects it into the
      application. Because a proxy is created at runtime, the specified Mapper
      <emphasis>must</emphasis> be an interface, not an implementation class.
    </para>

    <para>
      If the UserMapper has a corresponding MyBatis XML mapper file, it will be
      parsed automatically by the <literal>MapperFactoryBean</literal> if the
      XML file is in the same classpath location as the Mapper class. There
      is no need to specify the mapper in a MyBatis configuration file unless
      the mapper XML files are in a different classpath location. See the
      <literal>SqlSessionFactoryBean</literal>'s 
      <literal><link linkend="factorybean.configlocation">configLocation</link></literal>
      property for more information.
    </para>

    <para>
      Note that while <literal>MapperFactoryBean</literal> requires either an
      <literal>SqlSessionFactory</literal> or an
      <literal>SqlSessionTemplate</literal>. These can be set through the
      respective <literal>sqlSessionFactory</literal> or 
      <literal>sqlSessionTemplate</literal> properties or they can
      be autowired by Spring. If both properties are set, the 
      <literal>SqlSessionFactory</literal> is ignored, since the 
      <literal>SqlSessionTemplate</literal> is required to have a session
      factory set; that factory will be used by <literal>MapperFactoryBean</literal>.
    </para>
  </section>

  <section id="mappers.inject">
    <title>Injecting Mappers</title>

    <para>
       You can inject mappers directly on your business/service objects in the
       same way you inject any other Spring bean:

       <programlisting language="xml"><![CDATA[<bean id="fooService" class="org.mybatis.spring.sample.mapper.FooServiceImpl">
  <property name="userMapper" ref="userMapper" />
</bean>]]></programlisting>

       This bean can be used directly in application logic:

      <programlisting language="java"><![CDATA[public class FooService {
  private UserMapper userMapper;

  ...

  public User doSomeBusinessStuff(String userId) {
    return this.userMapper.getUser(userId);
  }
}]]></programlisting>

       Notice that there are no <literal>SqlSession</literal> or MyBatis
       references in this code.  Nor is there any need to create, open or close
       the session. If there is a Spring transaction in progress, the session
       will also be committed or rolled back when the transaction completes. 
     </para>
  </section>

  <section id="mappers.autoconfig">
    <title>Automatic Configuration</title>
    <para>
      There is no need to register all your mappers in the Spring XML file.
      Instead, you can use a <literal>MapperScannerPostProcessor</literal> that
      will search your classpath for your mappers and set them up
      automatically.        
    </para>

    <para>
      To set up a <literal>MapperScannerPostProcessor</literal> add the
      following to the Spring configuration:
      <programlisting language="xml"><![CDATA[<bean class="org.mybatis.spring.annotation.MapperScannerPostProcessor">
  <property name="basePackage" value="org.mybatis.spring.sample.mapper" />
</bean>]]></programlisting>

      The <literal>basePackage</literal> property lets you set the base package
      for your mapper interface files. You can set more than one package by
      using a semicolon or comma as a separator. Mappers will be searched
      recursively starting in the specified package(s).
    </para>
    
    <para>
      Notice that there is no need to specify a <literal>SqlSessionFactory</literal> or 
      <literal>SqlSessionTemplate</literal> because the <literal>MapperScannerPostProcessor</literal> 
      will create <literal>MapperFactoryBean</literal>s that can be autowired. But if you are
      using more than one <literal>DataSource</literal> autowire may not work for you. In this case
      you can use the <literal>sqlSessionFactoryBeanName</literal> or 
      <literal>sqlSessionTemplateBeanName</literal> properties to set the right bean name to use. 
      This is how it is configured, note that <emphasis>bean names</emphasis> are required, 
      not bean references, thus the <literal>value</literal> attribute is used instead of the 
      usual <literal>ref</literal>:
<programlisting language="xml"><![CDATA[<property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" />
]]></programlisting>
    </para>

    <para>
      To enable <literal>MapperScannerPostProcessor</literal> to identify your
      mapper classes they <emphasis>must</emphasis> be annotated with the
      <literal>@Mapper</literal> annotation.   

      <programlisting language="java"><![CDATA[@Mapper("userMapper")
public interface UserMapper {
    User getUser(String userId);
}]]></programlisting>

      The <literal>@Mapper</literal> annotation also lets you specify a name
      for your bean. If you don't provide a name it will be registered with its
      class name.
    </para>
   </section>

</chapter>
